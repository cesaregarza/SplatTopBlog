<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Forward vs Reverse PageRank (Deterministic Toy Model)</title>
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --text: #ffffff;
        --muted: #c9d1d9;
        --edge: rgba(255, 255, 255, 0.12);
        --grid: rgba(255, 255, 255, 0.08);
        --purple: #ab5ab7;
        --purple-light: #c183e1;
        --fuchsia: #d946ef;
        --cyan: #38bdf8;
        --glow: rgba(217, 70, 239, 0.28);
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; margin: 0; }

      body {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
        background:
          radial-gradient(circle at 20% 20%, rgba(217, 70, 239, 0.12), transparent 45%),
          radial-gradient(circle at 80% 10%, rgba(236, 72, 153, 0.12), transparent 40%),
          var(--bg);
        color: var(--text);
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      }

      html.is-embedded body {
        display: block;
        padding: 0;
        background: transparent;
      }

      html.is-embedded .applet {
        width: 100%;
        max-width: 100%;
      }

      .applet {
        width: min(1100px, 100%);
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), var(--panel));
        border: 1px solid var(--edge);
        border-radius: 16px;
        box-shadow: 0 18px 42px rgba(1, 4, 9, 0.55);
        overflow: hidden;
        position: relative;
      }

      .applet::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image:
          radial-gradient(circle at 10% 80%, rgba(255, 255, 255, 0.06), transparent 35%),
          radial-gradient(circle at 90% 30%, rgba(255, 255, 255, 0.04), transparent 40%);
        opacity: 0.4;
        pointer-events: none;
      }

      .header {
        position: relative;
        z-index: 1;
        display: flex;
        flex-wrap: wrap;
        gap: 12px 16px;
        align-items: center;
        justify-content: space-between;
        padding: 12px 14px;
        border-bottom: 1px solid rgba(255,255,255,0.10);
      }

      .meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 240px;
      }

      .title {
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .subtitle {
        font-size: 13px;
        color: var(--muted);
      }

      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .buttons {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        appearance: none;
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(255,255,255,0.06);
        color: var(--text);
        padding: 7px 10px;
        border-radius: 10px;
        font: inherit;
        cursor: pointer;
      }
      button:hover { background: rgba(255,255,255,0.10); }
      button:active { transform: translateY(1px); }

      .speed {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 14px;
      }

      input[type="range"] {
        width: 140px;
        height: 8px;
        appearance: none;
        -webkit-appearance: none;
        background: transparent;
        cursor: pointer;
        --range-fill: 50%;
      }

      input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: linear-gradient(
          90deg,
          rgba(232, 121, 249, 0.92) 0%,
          rgba(217, 70, 239, 0.85) var(--range-fill),
          rgba(255, 255, 255, 0.14) var(--range-fill),
          rgba(255, 255, 255, 0.14) 100%
        );
        border-radius: 9999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: inset 0 0 6px rgba(1, 4, 9, 0.35);
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, rgba(232, 121, 249, 0.95), rgba(217, 70, 239, 0.95));
        border: 2px solid rgba(255, 255, 255, 0.85);
        box-shadow: 0 0 10px rgba(217, 70, 239, 0.5);
        margin-top: -5px;
      }

      input[type="range"]::-moz-range-track {
        height: 8px;
        background: rgba(255, 255, 255, 0.14);
        border-radius: 9999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: inset 0 0 6px rgba(1, 4, 9, 0.35);
      }

      input[type="range"]::-moz-range-progress {
        height: 8px;
        background: linear-gradient(135deg, rgba(232, 121, 249, 0.95), rgba(217, 70, 239, 0.95));
        border-radius: 9999px;
      }

      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, rgba(232, 121, 249, 0.95), rgba(217, 70, 239, 0.95));
        border: 2px solid rgba(255, 255, 255, 0.85);
        box-shadow: 0 0 10px rgba(217, 70, 239, 0.5);
      }

      input[type="range"]::-moz-focus-outer {
        border: 0;
      }

      input[type="range"]:focus-visible {
        outline: 2px solid rgba(217, 70, 239, 0.55);
        outline-offset: 3px;
      }

      .status {
        color: var(--muted);
        font-size: 14px;
        white-space: nowrap;
      }

      .stage {
        position: relative;
        z-index: 1;
        padding: 12px 14px 16px;
        display: grid;
        grid-template-columns: minmax(0, 1.15fr) minmax(0, 1fr);
        gap: 16px;
        align-items: start;
      }

      .network-card {
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 14px;
        padding: 12px;
      }

      svg {
        width: 100%;
        height: auto;
        display: block;
      }

      .edge {
        stroke: rgba(217, 70, 239, 0.65);
        fill: none;
        stroke-linecap: round;
        transition: opacity 200ms ease;
      }

      .node circle {
        fill: rgba(15, 23, 42, 0.85);
        stroke-width: 2;
        filter: drop-shadow(0 0 12px var(--glow));
        transition: stroke 200ms ease, stroke-width 200ms ease;
      }

      .node text {
        font-size: 13px;
        font-weight: 700;
        fill: #ffffff;
        pointer-events: none;
      }

      .legend {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px 14px;
        font-size: 12px;
        color: var(--muted);
      }

      .legend-item {
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }

      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.25);
      }

      .swatch--edge {
        background: rgba(217, 70, 239, 0.7);
        border-radius: 4px;
      }

      .swatch--forward { background: var(--purple); }
      .swatch--reverse { background: var(--cyan); }

      .rankings {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
      }

      .rank-col {
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 14px;
        padding: 10px 12px 12px;
      }

      .rank-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .rank-subtitle {
        margin-top: 4px;
        font-size: 12px;
        color: rgba(201, 209, 217, 0.78);
      }

      .rank-list {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .rank-row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 10px;
        align-items: center;
      }

      .rank-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
      }

      .rank-name {
        font-weight: 700;
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .rank-meta {
        font-size: 11px;
        color: rgba(201, 209, 217, 0.7);
      }

      .rank-bar {
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 9999px;
        overflow: hidden;
      }

      .rank-bar span {
        display: block;
        height: 100%;
        width: 0%;
        border-radius: 9999px;
        transition: width 240ms ease;
      }

      .rank-value {
        font-variant-numeric: tabular-nums;
        font-size: 12px;
        color: var(--muted);
        min-width: 52px;
        text-align: right;
      }

      .rank-bar--split {
        position: relative;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 9999px;
        overflow: hidden;
      }

      .rank-bar--split::after {
        content: "";
        position: absolute;
        left: 50%;
        top: 0;
        bottom: 0;
        width: 1px;
        background: rgba(255, 255, 255, 0.2);
      }

      .rank-bar--split .bar-pos,
      .rank-bar--split .bar-neg {
        position: absolute;
        top: 0;
        height: 100%;
        width: 0%;
        transition: width 240ms ease;
      }

      .rank-bar--split .bar-pos {
        left: 50%;
        background: linear-gradient(90deg, var(--purple), var(--fuchsia));
      }

      .rank-bar--split .bar-neg {
        right: 50%;
        background: linear-gradient(90deg, var(--cyan), rgba(56, 189, 248, 0.6));
      }

      .value-pos { color: var(--purple-light); }
      .value-neg { color: var(--cyan); }

      @media (max-width: 900px) {
        .stage {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 740px) {
        .rankings {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 560px) {
        .header {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
        }

        .controls {
          width: 100%;
          display: grid;
          grid-template-columns: repeat(2, minmax(0, 1fr));
          gap: 8px;
        }

        .buttons {
          grid-column: 1 / -1;
          display: grid;
          grid-template-columns: repeat(2, minmax(0, 1fr));
          gap: 8px;
        }

        button {
          width: 100%;
          padding: 10px 12px;
          border-radius: 12px;
        }

        .speed {
          grid-column: 1 / -1;
          justify-content: space-between;
          width: 100%;
        }

        input[type="range"] { flex: 1; }

        .status {
          white-space: normal;
          line-height: 1.4;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          transition: none !important;
        }
      }
    </style>
  </head>

  <body>
    <div class="applet">
      <div class="header">
        <div class="meta">
          <div class="title">Forward vs Reverse PageRank</div>
          <div class="subtitle">Deterministic toy graph from skill + activity</div>
        </div>

        <div class="controls">
          <div class="buttons">
            <button id="btnPlay">Play</button>
            <button id="btnPause">Pause</button>
            <button id="btnStep">Step</button>
            <button id="btnReset">Reset</button>
          </div>

          <span class="speed">
            Speed
            <input id="speed" type="range" min="0.6" max="2.4" step="0.1" value="1.2" />
            <span id="speedLabel">1.2x</span>
          </span>
        </div>

        <div class="status" id="status">Ready.</div>
      </div>

      <div class="stage">
        <div class="network-card">
          <svg viewBox="0 0 620 420" role="img" aria-labelledby="title desc">
            <title id="title">Expected loss edges for a toy PageRank graph</title>
            <desc id="desc">Edges point from loser to winner; nodes outline by forward vs reverse dominance.</desc>

            <defs>
              <marker
                id="arrow"
                viewBox="0 0 12 12"
                refX="12"
                refY="6"
                markerWidth="12"
                markerHeight="12"
                orient="auto"
                markerUnits="userSpaceOnUse"
              >
                <path d="M 0 0 L 12 6 L 0 12 Z" fill="rgba(217, 70, 239, 0.9)"></path>
              </marker>
            </defs>

            <g id="edges"></g>
            <g id="nodes"></g>
          </svg>

          <div class="legend">
            <span class="legend-item"><span class="swatch swatch--edge"></span>Expected losses (loser -> winner)</span>
            <span class="legend-item"><span class="swatch swatch--forward"></span>Forward > Reverse</span>
            <span class="legend-item"><span class="swatch swatch--reverse"></span>Reverse > Forward</span>
          </div>
        </div>

        <div class="rankings">
          <div class="rank-col">
            <div class="rank-title">Forward PageRank</div>
            <div class="rank-subtitle">Volume-weighted wins</div>
            <div class="rank-list" id="forwardList"></div>
          </div>
          <div class="rank-col">
            <div class="rank-title">Reverse PageRank</div>
            <div class="rank-subtitle">Who loses to winners</div>
            <div class="rank-list" id="reverseList"></div>
          </div>
          <div class="rank-col">
            <div class="rank-title">Log Ratio</div>
            <div class="rank-subtitle">Forward / Reverse dominance</div>
            <div class="rank-list" id="ratioList"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const isEmbedded = (() => {
          try {
            return window.self !== window.top;
          } catch (err) {
            return true;
          }
        })();

        if (isEmbedded) {
          document.documentElement.classList.add("is-embedded");
        }

        const statusEl = document.getElementById("status");
        const btnPlay = document.getElementById("btnPlay");
        const btnPause = document.getElementById("btnPause");
        const btnStep = document.getElementById("btnStep");
        const btnReset = document.getElementById("btnReset");
        const speedInput = document.getElementById("speed");
        const speedLabel = document.getElementById("speedLabel");

        const appletEl = document.querySelector(".applet");
        const svg = document.querySelector("svg");
        const edgesLayer = document.getElementById("edges");
        const nodesLayer = document.getElementById("nodes");

        const forwardList = document.getElementById("forwardList");
        const reverseList = document.getElementById("reverseList");
        const ratioList = document.getElementById("ratioList");

        const players = [
          { id: "Ace", skill: 2.4, act: 0.6 },
          { id: "Pro", skill: 1.7, act: 1.1 },
          { id: "Gate", skill: 1.1, act: 1.3 },
          { id: "Grinder", skill: 0.8, act: 4.0 },
          { id: "Journeyman", skill: 0.2, act: 1.4 },
          { id: "Newbie", skill: -1.0, act: 2.0 },
        ];

        const config = {
          scale: 6.0,
          tau: 0.9,
          damping: 0.85,
          maxIters: 40,
          topK: 2,
        };

        function sigmoid(x) {
          return 1 / (1 + Math.exp(-x));
        }

        function buildExpectedLossGraph(list, opts) {
          const n = list.length;
          const W = Array.from({ length: n }, () => Array(n).fill(0));

          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              const ai = list[i].act;
              const aj = list[j].act;
              const matches = opts.scale * ai * aj;
              const p_i_wins = sigmoid((list[i].skill - list[j].skill) / opts.tau);
              const p_j_wins = 1 - p_i_wins;

              W[i][j] += matches * p_j_wins;
              W[j][i] += matches * p_i_wins;
            }
          }
          return W;
        }

        function transpose(W) {
          const n = W.length;
          const WT = Array.from({ length: n }, () => Array(n).fill(0));
          for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) WT[j][i] = W[i][j];
          }
          return WT;
        }

        function rowNormalize(W) {
          const n = W.length;
          const P = Array.from({ length: n }, () => Array(n).fill(0));
          for (let i = 0; i < n; i++) {
            const s = W[i].reduce((a, b) => a + b, 0);
            if (s > 0) {
              for (let j = 0; j < n; j++) P[i][j] = W[i][j] / s;
            } else {
              const u = 1 / n;
              for (let j = 0; j < n; j++) P[i][j] = u;
            }
          }
          return P;
        }

        function pageRankStep(r, P, d, teleport) {
          const n = r.length;
          const next = Array(n).fill(0);
          for (let i = 0; i < n; i++) {
            const ri = r[i];
            if (ri === 0) continue;
            for (let j = 0; j < n; j++) next[j] += d * ri * P[i][j];
          }
          for (let j = 0; j < n; j++) next[j] += (1 - d) * teleport[j];
          return next;
        }

        function logRatio(forward, reverse, eps) {
          return forward.map((x, i) => Math.log((x + eps) / (reverse[i] + eps)));
        }

        function buildTopEdges(W, k) {
          const edges = [];
          for (let i = 0; i < W.length; i++) {
            const picks = W[i]
              .map((w, j) => ({ j, w }))
              .filter((item) => item.j !== i)
              .sort((a, b) => b.w - a.w)
              .slice(0, k);

            picks.forEach((item) => {
              if (item.w > 0) edges.push({ from: i, to: item.j, w: item.w });
            });
          }
          return edges;
        }

        function circlePositions(cx, cy, radius, n) {
          const positions = [];
          for (let i = 0; i < n; i++) {
            const angle = ((-90 + (360 / n) * i) * Math.PI) / 180;
            positions.push({
              x: cx + radius * Math.cos(angle),
              y: cy + radius * Math.sin(angle),
            });
          }
          return positions;
        }

        function layoutSpec(name) {
          if (name === "narrow") {
            return {
              viewBox: "0 0 420 520",
              positions: circlePositions(210, 220, 150, players.length),
            };
          }
          return {
            viewBox: "0 0 620 420",
            positions: circlePositions(310, 200, 160, players.length),
          };
        }

        function applyLayout(name) {
          const spec = layoutSpec(name);
          svg.setAttribute("viewBox", spec.viewBox);
          nodePositions = spec.positions;

          nodes.forEach((node, idx) => {
            const p = nodePositions[idx];
            node.group.setAttribute("transform", `translate(${p.x} ${p.y})`);
          });

          updateEdgesGeometry();
        }

        function getLayoutForWidth(wPx) {
          return wPx < 680 ? "narrow" : "wide";
        }

        function setStatus(msg) {
          statusEl.textContent = msg;
        }

        function setRangeFill() {
          const min = parseFloat(speedInput.min);
          const max = parseFloat(speedInput.max);
          const val = parseFloat(speedInput.value);
          if (Number.isNaN(min) || Number.isNaN(max) || max === min) {
            speedInput.style.setProperty("--range-fill", "50%");
            return;
          }
          const pct = ((val - min) / (max - min)) * 100;
          speedInput.style.setProperty("--range-fill", `${pct.toFixed(1)}%`);
        }

        function setSpeedLabel() {
          const s = parseFloat(speedInput.value);
          speedLabel.textContent = `${s.toFixed(1)}x`;
          setRangeFill();
          return s;
        }

        const W = buildExpectedLossGraph(players, config);
        const WT = transpose(W);
        const P = rowNormalize(W);
        const PT = rowNormalize(WT);
        const teleport = Array(players.length).fill(1 / players.length);

        const edges = buildTopEdges(W, config.topK);
        const maxEdge = edges.reduce((m, e) => Math.max(m, e.w), 0) || 1;

        const nodes = [];
        const edgeEls = [];
        let nodePositions = [];
        let iteration = 0;
        let playing = false;
        let forward = teleport.slice();
        let reverse = teleport.slice();

        function buildSvgNodes() {
          nodesLayer.innerHTML = "";
          players.forEach((player, idx) => {
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.classList.add("node");
            group.dataset.idx = String(idx);

            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("r", "22");
            circle.setAttribute("stroke", "rgba(255, 255, 255, 0.25)");
            circle.setAttribute("stroke-width", "2");

            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("text-anchor", "middle");
            label.setAttribute("dominant-baseline", "middle");
            label.textContent = player.id;

            group.appendChild(circle);
            group.appendChild(label);
            nodesLayer.appendChild(group);

            nodes.push({ group, circle, label });
          });
        }

        function buildSvgEdges() {
          edgesLayer.innerHTML = "";
          edgeEls.length = 0;
          edges.forEach((edge) => {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.classList.add("edge");
            path.setAttribute("marker-end", "url(#arrow)");

            const weight = edge.w / maxEdge;
            path.style.opacity = (0.25 + 0.65 * weight).toFixed(2);
            path.style.strokeWidth = (1.2 + 2.2 * weight).toFixed(2);

            edgesLayer.appendChild(path);
            edgeEls.push({ edge, path });
          });
        }

        function updateEdgesGeometry() {
          edgeEls.forEach(({ edge, path }) => {
            const from = nodePositions[edge.from];
            const to = nodePositions[edge.to];
            if (!from || !to) return;

            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const len = Math.hypot(dx, dy) || 1;
            const ux = dx / len;
            const uy = dy / len;
            const r = 24;

            const x1 = from.x + ux * r;
            const y1 = from.y + uy * r;
            const x2 = to.x - ux * r;
            const y2 = to.y - uy * r;

            path.setAttribute("d", `M ${x1.toFixed(2)} ${y1.toFixed(2)} L ${x2.toFixed(2)} ${y2.toFixed(2)}`);
          });
        }

        function colorForDominance(value) {
          return value >= 0 ? "var(--purple)" : "var(--cyan)";
        }

        function widthForDominance(value) {
          return (2 + Math.min(4, Math.abs(value) * 2)).toFixed(2);
        }

        function updateNodes(dom) {
          nodes.forEach((node, idx) => {
            const value = dom[idx];
            node.circle.setAttribute("stroke", colorForDominance(value));
            node.circle.setAttribute("stroke-width", widthForDominance(value));
          });
        }

        function formatMeta(player) {
          return `s ${player.skill.toFixed(1)} | a ${player.act.toFixed(1)}`;
        }

        function renderRankList(container, values, opts) {
          const order = values
            .map((v, i) => ({ v, i }))
            .sort((a, b) => b.v - a.v);

          container.innerHTML = "";
          if (!order.length) return;

          const maxVal = Math.max(...values, 0.0001);
          order.forEach((item) => {
            const player = players[item.i];
            const row = document.createElement("div");
            row.className = "rank-row";

            const info = document.createElement("div");
            info.className = "rank-info";

            const name = document.createElement("div");
            name.className = "rank-name";
            name.textContent = player.id;

            const meta = document.createElement("div");
            meta.className = "rank-meta";
            meta.textContent = formatMeta(player);

            const bar = document.createElement("div");
            bar.className = "rank-bar";
            const barFill = document.createElement("span");
            barFill.style.width = `${(item.v / maxVal) * 100}%`;
            barFill.style.background = opts.barColor;

            bar.appendChild(barFill);
            info.appendChild(name);
            info.appendChild(meta);
            info.appendChild(bar);

            const value = document.createElement("div");
            value.className = "rank-value";
            value.textContent = item.v.toFixed(4);

            row.appendChild(info);
            row.appendChild(value);
            container.appendChild(row);
          });
        }

        function renderRatioList(container, values) {
          const order = values
            .map((v, i) => ({ v, i }))
            .sort((a, b) => b.v - a.v);

          container.innerHTML = "";
          if (!order.length) return;

          const maxAbs = Math.max(...values.map((v) => Math.abs(v)), 0.0001);
          order.forEach((item) => {
            const player = players[item.i];
            const row = document.createElement("div");
            row.className = "rank-row";

            const info = document.createElement("div");
            info.className = "rank-info";

            const name = document.createElement("div");
            name.className = "rank-name";
            name.textContent = player.id;

            const meta = document.createElement("div");
            meta.className = "rank-meta";
            meta.textContent = formatMeta(player);

            const bar = document.createElement("div");
            bar.className = "rank-bar--split";
            const pos = document.createElement("span");
            pos.className = "bar-pos";
            const neg = document.createElement("span");
            neg.className = "bar-neg";

            if (item.v >= 0) {
              pos.style.width = `${(Math.abs(item.v) / maxAbs) * 100}%`;
              neg.style.width = "0%";
            } else {
              neg.style.width = `${(Math.abs(item.v) / maxAbs) * 100}%`;
              pos.style.width = "0%";
            }

            bar.appendChild(pos);
            bar.appendChild(neg);
            info.appendChild(name);
            info.appendChild(meta);
            info.appendChild(bar);

            const value = document.createElement("div");
            value.className = `rank-value ${item.v >= 0 ? "value-pos" : "value-neg"}`;
            value.textContent = item.v.toFixed(3);

            row.appendChild(info);
            row.appendChild(value);
            container.appendChild(row);
          });
        }

        function updateUI() {
          const dom = logRatio(forward, reverse, 1e-12);
          updateNodes(dom);

          renderRankList(forwardList, forward, { barColor: "rgba(217, 70, 239, 0.75)" });
          renderRankList(reverseList, reverse, { barColor: "rgba(56, 189, 248, 0.85)" });
          renderRatioList(ratioList, dom);

          setStatus(`Iter ${iteration}/${config.maxIters} | d ${config.damping.toFixed(2)} | tau ${config.tau.toFixed(1)}`);
        }

        async function runOneStep() {
          if (iteration >= config.maxIters) {
            setStatus("Converged. Reset to replay.");
            return;
          }
          forward = pageRankStep(forward, P, config.damping, teleport);
          reverse = pageRankStep(reverse, PT, config.damping, teleport);
          iteration += 1;
          updateUI();

          if (iteration >= config.maxIters) {
            setStatus("Converged. Forward and reverse ranks stabilized.");
          }
        }

        async function playLoop() {
          if (playing) return;
          playing = true;

          while (playing && iteration < config.maxIters) {
            await runOneStep();
            const speed = setSpeedLabel();
            await new Promise((r) => setTimeout(r, Math.round(220 / speed)));
          }

          playing = false;
        }

        function pause() {
          playing = false;
          setStatus("Paused.");
        }

        function reset() {
          playing = false;
          iteration = 0;
          forward = teleport.slice();
          reverse = teleport.slice();
          updateUI();
        }

        function handleResize(widthPx) {
          const next = getLayoutForWidth(widthPx);
          applyLayout(next);
        }

        function initLayout() {
          const width = appletEl.getBoundingClientRect().width;
          handleResize(width);
        }

        if ("ResizeObserver" in window) {
          const ro = new ResizeObserver((entries) => {
            if (!entries.length) return;
            handleResize(entries[0].contentRect.width);
          });
          ro.observe(appletEl);
        } else {
          window.addEventListener("resize", () => {
            handleResize(appletEl.getBoundingClientRect().width);
          });
        }

        buildSvgNodes();
        buildSvgEdges();
        initLayout();

        btnPlay.addEventListener("click", playLoop);
        btnPause.addEventListener("click", pause);
        btnStep.addEventListener("click", async () => { pause(); await runOneStep(); });
        btnReset.addEventListener("click", reset);
        speedInput.addEventListener("input", () => setSpeedLabel());

        reset();
        setSpeedLabel();
      })();
    </script>
  </body>
</html>
