{% extends "base.html" %}
{% load wagtailcore_tags wagtailimages_tags wagtailmarkdown %}

{% block content %}
<div class="post-layout">
    <article class="post">
        <header class="post-header">
            <h1 class="post-title">{{ page.title }}</h1>
            {% if page.date %}
                <p class="post-meta">
                    <time datetime="{{ page.date|date:'Y-m-d' }}">{{ page.date }}</time>
                </p>
            {% endif %}
            <div class="post-readtime" id="postReadTime" aria-live="polite">
                <span class="post-readtime__main">Main path: -- min</span>
                <span class="post-readtime__divider">•</span>
                <span class="post-readtime__deep">With deep dives: -- min</span>
            </div>
        </header>

        {% if page.featured_image %}
            {% image page.featured_image width-800 as img %}
            <img src="{{ img.url }}" alt="{{ page.title }}" class="featured-image">
        {% endif %}

        <div class="content post-content">
            {% for block in page.body %}
                {% include "blog/blocks/render_block.html" with block=block %}
            {% endfor %}
        </div>
    </article>

    <aside class="post-sidebar" aria-label="Post navigation">
        <div class="post-toc">
            <div class="post-toc__progress">
                <span class="post-toc__progress-bar" id="postTocProgress"></span>
            </div>
            <div class="post-toc__header">
                <div class="post-toc__eyebrow">You are here</div>
                <div class="post-toc__crumb" id="postTocCrumb">Loading...</div>
            </div>
            <div class="post-toc__title">On this page</div>
            <nav class="post-toc__nav" aria-label="Table of contents">
                <ul class="post-toc__list" id="postTocList"></ul>
            </nav>
        </div>
    </aside>
    <div class="post-toc-backdrop" id="postTocBackdrop" aria-hidden="true"></div>
</div>

<nav class="post-nav">
    <a href="{{ page.get_parent.url }}">&larr; Back to posts</a>
</nav>
{% endblock %}

{% block header_actions %}
<button class="post-toc-drawer-toggle" id="postTocDrawerToggle" type="button" aria-expanded="false">
    <span class="post-toc-drawer-toggle__icon" aria-hidden="true"><span></span></span>
    <span class="post-toc-drawer-toggle__label">Outline</span>
</button>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener("DOMContentLoaded", () => {
        const setScrollOffset = () => {
            const header = document.querySelector(".site-header");
            if (!header) return;
            const height = header.getBoundingClientRect().height;
            const offset = Math.ceil(height + 16);
            document.documentElement.style.setProperty("--site-header-offset", `${offset}px`);
        };

        setScrollOffset();
        window.addEventListener("resize", setScrollOffset);

        const content = document.querySelector(".post-content");
        const readTimeEl = document.getElementById("postReadTime");
        const tocList = document.getElementById("postTocList");
        const crumbEl = document.getElementById("postTocCrumb");
        const toc = document.querySelector(".post-toc");
        const progressEl = document.getElementById("postTocProgress");
        const drawerToggle = document.getElementById("postTocDrawerToggle");
        const backdrop = document.getElementById("postTocBackdrop");
        if (!content || !tocList || !crumbEl || !toc) return;

        const wordRegex = /[A-Za-z0-9]+(?:'[A-Za-z0-9]+)?/g;
        const countWordsInString = (text) => (text.match(wordRegex) || []).length;
        const mathCharsPerWord = 8;

        const countMathWords = (el) => {
            const annotations = el.querySelectorAll("annotation[encoding='application/x-tex']");
            let tex = "";
            annotations.forEach((node) => {
                if (node.textContent) tex += ` ${node.textContent}`;
            });
            if (!tex) {
                tex = el.textContent || "";
            }
            const compact = tex.replace(/\s+/g, "");
            if (!compact) return 0;
            return Math.max(1, Math.ceil(compact.length / mathCharsPerWord));
        };

        const countTableWords = (table) => {
            let total = 0;
            table.querySelectorAll("th, td").forEach((cell) => {
                const text = (cell.textContent || "").trim();
                const words = countWordsInString(text);
                if (words === 0 && text.length > 0) {
                    total += 1;
                } else {
                    total += words;
                }
            });
            return total;
        };

        const countNode = (node, options) => {
            if (!node) return 0;
            if (node.nodeType === Node.TEXT_NODE) {
                return countWordsInString(node.textContent || "");
            }
            if (node.nodeType !== Node.ELEMENT_NODE) {
                return 0;
            }

            const el = node;
            if (
                el.matches("script, style, nav") ||
                el.classList.contains("para-anchor") ||
                el.classList.contains("post-toc") ||
                el.classList.contains("post-sidebar")
            ) {
                return 0;
            }

            if (el.classList.contains("katex") || el.classList.contains("katex-display") || el.classList.contains("latex-block")) {
                return countMathWords(el);
            }

            if (el.tagName === "TABLE") {
                return countTableWords(el);
            }

            if (el.tagName === "DETAILS" && el.classList.contains("collapsible-block")) {
                let total = 0;
                const summary = el.querySelector(":scope > summary");
                if (summary) {
                    total += countNode(summary, options);
                }
                const includeContent = options.includeClosed || el.hasAttribute("open");
                if (includeContent) {
                    Array.from(el.children).forEach((child) => {
                        if (summary && child === summary) return;
                        total += countNode(child, options);
                    });
                }
                return total;
            }

            let sum = 0;
            el.childNodes.forEach((child) => {
                sum += countNode(child, options);
            });
            return sum;
        };

        const formatMinutes = (words) => {
            const wordsPerMinute = 220;
            const minutes = Math.max(1, Math.round(words / wordsPerMinute));
            return `${minutes} min`;
        };

        if (readTimeEl) {
            const mainWords = countNode(content, { includeClosed: false });
            const deepWords = countNode(content, { includeClosed: true });
            const mainEl = readTimeEl.querySelector(".post-readtime__main");
            const deepEl = readTimeEl.querySelector(".post-readtime__deep");
            if (mainEl) mainEl.textContent = `Main path: ${formatMinutes(mainWords)}`;
            if (deepEl) deepEl.textContent = `With deep dives: ${formatMinutes(deepWords)}`;
        }

        const anchorSlugCounts = new Map();
        const slugify = (text, prefix = "") => {
            const base = text
                .toLowerCase()
                .replace(/[^a-z0-9\\s-]/g, "")
                .trim()
                .replace(/\\s+/g, "-");
            const key = `${prefix}:${base}`;
            const count = anchorSlugCounts.get(key) || 0;
            anchorSlugCounts.set(key, count + 1);
            const suffix = count ? `-${count + 1}` : "";
            if (!base) {
                return `section-${anchorSlugCounts.size}`;
            }
            return `${base}${suffix}`;
        };

        const addAnchor = (el, prefix, explicitId = "", textOverride = "") => {
            if (!el || el.querySelector(".para-anchor")) return;
            const rawText = textOverride || (el.textContent || "");
            const text = rawText.trim();
            if (!text && !explicitId && !el.id) return;
            let id = el.id || explicitId;
            if (!id) {
                const slugSource = text.split(/\s+/).slice(0, 12).join(" ");
                const base = slugify(slugSource, prefix);
                id = prefix ? `${prefix}-${base}` : base;
            }
            el.id = id;
            const anchor = document.createElement("a");
            anchor.className = "para-anchor";
            anchor.href = `#${id}`;
            anchor.textContent = "";
            anchor.setAttribute("aria-label", `Copy link to ${text || "section"}`);
            anchor.addEventListener("click", () => {
                const url = `${window.location.origin}${window.location.pathname}#${id}`;
                navigator.clipboard?.writeText(url).catch(() => {});
            });
            el.prepend(anchor);
        };

        content.querySelectorAll("p").forEach((p) => {
            addAnchor(p, "p");
        });
        content.querySelectorAll("h2, h3, h4, h5, h6").forEach((heading) => {
            addAnchor(heading, "h");
        });
        content.querySelectorAll(".collapsible-block__summary").forEach((summary) => {
            const titleEl = summary.querySelector(".collapsible-block__title");
            const text = titleEl ? titleEl.textContent.trim() : summary.textContent.trim();
            if (!text) return;
            addAnchor(summary, "c", "", text);
        });

        const headings = Array.from(
            content.querySelectorAll("h2, h3")
        );

        if (headings.length === 0) {
            const sidebar = toc.closest(".post-sidebar");
            if (sidebar) sidebar.style.display = "none";
            if (drawerToggle) drawerToggle.style.display = "none";
            return;
        }

        const headingMeta = [];
        let currentH2 = "";

        headings.forEach((heading) => {
            const text = heading.textContent.trim();
            if (!heading.id) {
                const base = slugify(text, "h");
                heading.id = `h-${base}`;
            }
            const level = heading.tagName.toLowerCase();
            if (level === "h2") {
                currentH2 = text;
            }

            headingMeta.push({
                id: heading.id,
                text,
                level,
                parent: level === "h3" ? currentH2 : "",
            });
        });

        headingMeta.forEach((meta) => {
            const li = document.createElement("li");
            li.className = "post-toc__item";
            if (meta.level === "h3") {
                li.classList.add("post-toc__item--sub");
            }

            const link = document.createElement("a");
            link.className = "post-toc__link";
            link.href = `#${meta.id}`;
            link.textContent = meta.text || meta.id;
            link.dataset.tocId = meta.id;
            li.appendChild(link);
            tocList.appendChild(li);
        });

        const links = Array.from(tocList.querySelectorAll(".post-toc__link"));

        if (headings.length <= 2) {
            toc.classList.add("post-toc--compact");
        }

        const setScrollbarOffset = (value) => {
            document.documentElement.style.setProperty("--scrollbar-offset", value);
        };

        const openDrawer = () => {
            const scrollBarWidth = Math.max(
                0,
                window.innerWidth - document.documentElement.clientWidth
            );
            setScrollbarOffset(`${scrollBarWidth}px`);
            document.body.classList.add("toc-drawer-open");
            if (drawerToggle) drawerToggle.setAttribute("aria-expanded", "true");
        };

        const closeDrawer = () => {
            document.body.classList.remove("toc-drawer-open");
            setScrollbarOffset("0px");
            if (drawerToggle) drawerToggle.setAttribute("aria-expanded", "false");
        };

        if (drawerToggle) {
            drawerToggle.addEventListener("click", () => {
                if (document.body.classList.contains("toc-drawer-open")) {
                    closeDrawer();
                } else {
                    openDrawer();
                }
            });
        }

        if (backdrop) {
            backdrop.addEventListener("click", closeDrawer);
        }

        window.addEventListener("keydown", (event) => {
            if (event.key === "Escape") closeDrawer();
        });

        const updateActive = (id) => {
            links.forEach((link) => {
                link.classList.toggle("is-active", link.dataset.tocId === id);
            });
            const meta = headingMeta.find((entry) => entry.id === id);
            if (!meta) return;
            if (meta.level === "h3" && meta.parent) {
                crumbEl.textContent = `${meta.parent} → ${meta.text}`;
            } else {
                crumbEl.textContent = meta.text;
            }
        };

        let ticking = false;
        const updateProgress = () => {
            if (!progressEl) return;
            const top = content.offsetTop;
            const height = content.offsetHeight;
            const viewport = window.innerHeight;
            const maxScroll = Math.max(1, height - viewport);
            const scrollY = window.scrollY - top;
            const progress = Math.min(1, Math.max(0, scrollY / maxScroll));
            progressEl.style.width = `${(progress * 100).toFixed(2)}%`;
        };

        const onScroll = () => {
            if (ticking) return;
            ticking = true;
            window.requestAnimationFrame(() => {
                const fromTop = window.scrollY + 140;
                let current = headings[0];
                for (const heading of headings) {
                    if (heading.offsetTop <= fromTop) {
                        current = heading;
                    } else {
                        break;
                    }
                }
                if (current) updateActive(current.id);
                updateProgress();
                ticking = false;
            });
        };

        window.addEventListener("scroll", onScroll, { passive: true });
        const handleResize = () => {
            onScroll();
            if (window.matchMedia("(min-width: 1100px)").matches) {
                closeDrawer();
            }
        };

        window.addEventListener("resize", handleResize);
        handleResize();

        links.forEach((link) => {
            link.addEventListener("click", () => {
                closeDrawer();
            });
        });
    });
</script>
{% endblock %}
